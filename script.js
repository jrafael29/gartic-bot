(function () {
  window.respostasAcerto_objetos = [ 
    "guitarra", "luva", "cama el√°stica", "cart√£o de mem√≥ria", "bo√°", "abajur", "la√ßo", "bandolim", "cadar√ßo", "chap√©u", "carimbo", "saco de pl√°stico", "abafador", "pregador", "lanterna", "escorredor de macarr√£o", "computador", "grinalda", "borrifador", "gaveta", "sunga", "fantoche", "escova", "t√™nis", "esponja", "talco", "desentupidor", "aro", "impressora", "notebook", "torneira", "crach√°", "volante", "espeto", "palheta", "mon√≥culo", "penteadeira", "esparadrapo", "cama", "munhequeira", "lixeira", "ferradura", "arco", "vassoura", "papel", "paraquedas", "arame farpado", "alargador", "barril", "jarra", "mai√¥", "x√≠cara", "lapiseira", "prateleira", "pia", "tobog√£", "poltrona", "anzol", "pilha", "toalha de mesa", "ventilador", "ratoeira", "envelope", "cart√£o postal", "salto alto", "espanador", "porta-l√°pis", "ferro de passar roupa", "p√™ndulo", "tampa", "clipe", "camisa", "rasteirinha", "gaita", "lixa de unha", "urna", "controle remoto", "caixa registradora", "fita cassete", "macac√£o", "espelho", "telha", "sand√°lia", "l√°pis de cor", "tri√¢ngulo", "dinamite", "taco", "prancha", "l√¢mina", "toalha", "cal√ßa", "gravata", "estilingue", "para-raios", "jardineira", "rolha", "vasilha", "tamborim", "caixote", "caldeir√£o", "sapateira", "retrovisor", "gibi", "farda", "bicho de pel√∫cia", "jeans", "convite", "barbeador", "estilete", "flauta", "mouse pad", "leque", "casaco", "desodorante", "bazuca", "gancho", "regador", "brinco", "chip", "serra", "martelo", "micro-ondas", "microfone", "fuzil", "borracha", "esquadro", "cristal", "jaqueta", "chupeta", "cutelo", "dado", "saia", "farolete", "perfurador de papel", "boia", "bicama", "alfinete", "arp√£o", "tapete", "torradeira", "buzina", "r√°dio", "espremedor de alho", "saladeira", "panela", "ba√∫", "pistola", "baqueta", "coroa", "m√°scara cir√∫rgica", "telefone", "batom", "amortecedor", "bomba", "holofote", "viol√£o", "colete", "gargantilha", "bermuda", "nariz de palha√ßo", "colch√£o", "batente", "panela de barro", "bal√£o", "monitor", "biqu√≠ni", "mi√ßanga", "picareta", "tambor", "pneu", "concha", "pente", "churrasqueira", "lan√ßa", "papel higi√™nico", "mapa", "mesa de ping-pong", "sem√°foro", "rev√≥lver", "palito de f√≥sforo", "bandana", "bola", "capa", "cadeira de rodas", "fita", "boneca", "papel laminado", "banheira", "capacete", "detector de metais", "saxofone", "interfone", "caixa de som", "muleta", "buqu√™", "marcador de p√°gina", "r√©gua", "carrinho de m√£o", "chuveiro", "bandeira", "z√≠per", "quebra-nozes", "faca", "espiral", "pote", "porta-retrato", "rede", "cabide", "t√°bua", "cuia", "estatueta do oscar", "chocalho", "cinto de seguran√ßa", "mamadeira", "meia-cal√ßa", "ber√ßo", "coleira", "cavalo de pau", "revista", "rede de descanso", "pato de borracha", "celular", "ma√ßaneta", "anel", "fita crepe", "cata-vento", "batedeira", "fronha", "cesta", "vela", "grelha", "cone", "balaio", "gesso", "guarda-roupa", "mochila", "foguete", "forma", "retrato", "seringa", "cantoneira", "pil√£o", "machado", "colar", "tamanco", "lousa", "escumadeira", "fio", "cachecol", "abridor de garrafa", "lata", "presente", "minissaia", "skate", "canudo", "sino", "caneta hidrocor", "cadeado", "mesa", "rastelo", "zarabatana", "cofre", "cavaquinho", "alto falante", "p√©rola", "cart√£o", "furadeira", "ombreira", "apontador de l√°pis", "√≥culos de sol", "bast√£o", "pandeiro", "terno", "canivete", "maca", "morda√ßa", "√≥culos", "marcador de texto", "el√°stico", "giz de cera", "v√≠deo game", "pingente", "caneca", "camisa regata", "extintor de inc√™ndio", "quebra-cabe√ßa", "charuto", "guardanapo", "ralador", "sapatilha", "webcam", "pulseira", "gorro", "escavadeira", "violoncelo", "fog√£o a lenha", "boina", "chuteira", "tornozeleira", "fich√°rio", "rabeca", "tubo de ensaio", "banco", "despertador", "cano", "esfigmoman√¥metro", "bola de golfe", "bateria", "trombone", "pino", "caixa de ferramentas", "bin√≥culo", "alicate", "manequim", "bola de boliche", "dvd", "agulha de croch√™", "diamante", "guid√£o", "televis√£o", "harpa", "esp√°tula", "avental", "bule", "balan√ßa", "algod√£o", "raquete el√©trica", "caixa de correio", "pijama", "colher", "lupa", "garrafa", "b√≠blia", "antena", "alicate de unha", "aspirador de p√≥", "bilhete", "espada", "algema", "scanner", "bumerangue", "faixa", "cd", "alian√ßa", "chap√©u de anivers√°rio", "r√≠mel", "suti√£", "arm√°rio", "vidro", "vaso sanit√°rio", "janela", "dobradi√ßa", "farinheiro", "len√ßo", "suspens√≥rio", "forno", "l√¢mpada", "cobertor", "cabo", "talher", "armadura", "dardo", "apagador", "cafeteira", "chaveiro", "caixa", "clarinete", "p√≥dio", "fivela", "cadeira", "fita adesiva", "livro", "canga", "chinelo", "p√© de cabra", "short", "catraca", "marreta", "rel√≥gio", "chave", "m√≠ssil", "cortador de unha", "leiteira", "balde", "asa delta", "maquete", "escada", "flanela", "andaime", "saca-rolhas", "estante", "lista telef√¥nica", "cartucho de tinta", "dedal", "ponteiro", "berimbau", "porta cd", "brilho labial", "armadilha", "p√°", "lente de contato", "fio dental", "√°lbum", "mouse", "pergaminho", "chave de fenda", "trave", "escorregador", "fruteira", "palmilha", "cachimbo", "cocar", "esfreg√£o", "crucifixo", "pi√£o", "trompete", "calota", "focinheira", "pacote", "mala", "ralo", "colher de pau", "teclado", "bisturi", "quimono", "tablet", "sombrinha", "prendedor de cabelo", "caixa de f√≥sforo", "√≠m√£", "ca√ßarola", "meia", "colchonete", "rack", "tela", "queijeira", "poster", "catapulta", "torpedo", "rodo", "disquete", "joelheira", "secadora", "h√©lice", "claquete", "fog√£o", "su√©ter", "estabilizador", "jangada", "pires", "bengala", "secador de cabelo", "marionete", "prego", "chave de boca", "aljava", "chapinha de cabelo", "aqu√°rio", "b√∫ssola", "vaso", "travesseiro", "carteira", "corpete", "filtro de linha", "p√° de lixo", "geladeira", "varal", "√¢ncora", "tanque", "serrote", "spray", "caix√£o", "ralo de pia", "bola de gude", "sapato", "assadeira", "√≥rg√£o", "guarda-chuva", "escova de dente", "bon√©", "persiana", "patinete", "guilhotina", "faqueiro", "cola", "confete", "frigobar", "garrafa t√©rmica", "abridor de latas", "proj√©til", "di√°rio", "c√¥moda", "caderno", "col√≠rio", "cinto", "escapamento", "flecha", "filtro de √°gua", "pedra-pomes", "delineador", "obo√©", "vitrola", "figurinha", "patins", "detector de fuma√ßa", "cart√£o de cr√©dito", "pano", "barraca", "lanterna chinesa", "bolsa t√©rmica", "aquecedor", "mesa de sinuca", "tijolo", "apito", "sanfona", "tumba", "disco", "escudo", "raquete", "peteca", "trof√©u", "trono", "caneta", "bacia", "pen drive", "agulha", "brinquedo", "cadeira de balan√ßo", "cueca", "roteador", "pipa", "navalha", "rede de pesca", "garrafa pet", "mola", "cristaleira", "len√ßol", "caixa de papel√£o", "caixa de isopor", "pedal", "escopeta", "fus√≠vel", "tinta de cabelo", "mordedor", "pipoqueira", "bota", "conta-gotas", "lustre", "cortador de grama", "camisola", "escrivaninha", "chave de roda", "espartilho", "corretivo", "ampulheta", "rel√≥gio de pulso", "bala√∫stre", "isqueiro", "m√°scara de mergulho", "bolsa", "alarme", "iate", "estojo", "calcinha", "contrabaixo", "retroprojetor", "placa", "grampo de cabelo", "lantejoula", "violino", "vestido", "cruzeta", "cisterna", "compasso", "giz", "prato", "l√°pis", "punhal", "tigela", "galocha", "medalha", "pisca-pisca", "narguil√©", "palito de dente", "parabrisa", "cadeira de praia", "zabumba", "√°rvore de natal", "saboneteira", "baf√¥metro", "carrinho de feira", "piercing", "soco ingl√™s", "unha posti√ßa", "l√£ de a√ßo", "haltere", "m√°quina de lavar roupa", "transferidor", "filtro de papel", "chicote", "cadeira el√©trica", "l√≠ngua de sogra", "granada", "bomba de ar", "cerca el√©trica", "almofada", "frigideira", "azulejo", "cortina", "cal√ßadeira", "colcha", "gangorra", "chaleira", "forno el√©trico", "p√© de pato", "podadeira", "novelo de l√£", "presilha", "caxixi", "antena parab√≥lica", "mosquiteiro", "autorama", "est√°tua", "hidrante", "filmadora", "guirlanda", "puxador", "bambol√™", "camisa de for√ßa", "botij√£o de g√°s", "colete cervical", "l√°pis de olho", "biruta", "bigorna", "camiseta", "lampi√£o", "fones de ouvido", "l√°pis labial", "guindaste", "turbina", "copo", "tesoura", "estojo de maquiagem", "agulheiro", "lumin√°ria", "tridente", "viola", "radar", "rimel", "cita-liga", "fritadeira el√©trica", "domin√≥", "fantasia", "lamparina", "bandeja", "coador", "multiprocessador", "corrente", "espremedor de frutas", "fax", "jornal", "uniforme", "v√©u", "base", "bata", "beca", "bid√™", "b√≥ia", "cera", "clip", "cruz", "div√£", "elmo", "grua", "ioi√¥", "leme", "lira", "lona", "oboe", "odre", "puff", "remo", "roda", "sof√°", "ta√ßa", "tear", "xale", "√°paco", "adaga", "alz√£o", "baixo", "balsa", "banjo", "blusa", "blush", "bot√£o", "broca", "bucha", "burca", "canoa", "carta", "cetro", "clava", "coifa", "conga", "corda", "cu√≠ca", "draga", "fac√£o", "foice", "funil", "ganz√°", "garfo", "kunai", "laqu√™", "lente", "manta", "modem", "moeda", "motor", "mural", "ofur√¥", "org√£o", "parca", "pasta", "piano", "pin√ßa", "pluma", "porta", "quepe", "r√©dea", "rifle", "sabre", "tanga", "tiara", "toldo", "touca", "agenda", "ala√∫de", "anilha", "batina", "batuta", "bornal", "botina", "broche", "cajado", "c√°lice", "cantil", "capelo", "enxada", "estaca", "fagote", "form√£o", "frasco", "gaiola", "jaleco", "lajota", "luneta", "marac√°", "mastro", "palet√≥", "papete", "peruca", "pincel", "pipeta", "planta", "pomada", "quadro", "rodap√©", "sirene", "sombra", "tatame", "tecido", "trompa", "t√∫nica", "acetona", "bobina", "andador", "balan√ßo", "estetosc√≥pio", "fita isolante", "guarda-sol", "metr√¥", "m√°quina fotogr√°fica", "m√°quina de lavar", "term√¥metro", "telesc√≥pio" 
  ];
  window.respostasAcerto_alimentos = [
    "castanha", "leite em p√≥", "sandu√≠che", "broto de feij√£o", "mousse de morango", "arroz tropeiro", "farinha0", "ch√°", "mel", "ovo", "sal grosso", "p√£o", "rum", "sal", "uva", "abiu", "a√ßa√≠", "√°gua", "aipo", "alho", "angu", "bala", "bife", "bolo", "broa", "caf√©", "caj√°", "caju", "coco", "figo", "fil√©", "flan", "fub√°", "gema", "ing√°", "jaca", "jil√≥", "kiwi", "lima", "ma√ß√£", "mate", "nabo", "√≥leo", "pat√™", "pav√™", "pera", "pur√™", "rom√£", "sagu", "soja", "sopa", "suco", "umbu", "aipim", "amora", "ara√ßa", "arroz", "aveia", "avel√£", "bacon", "bauru", "cacau", "caqui", "carne", "chopp", "cidra", "clara", "couve", "cravo", "crepe", "curau", "curry", "glac√™", "jambo", "jata√≠", "leite", "licor", "lim√£o", "lombo", "louro", "mam√£o", "manga", "mel√£o", "menta", "milho", "nozes", "orob√¥", "pequi", "pinha", "pir√£o", "pizza", "pudim", "quibe", "ra√ß√£o", "salsa", "saqu√™", "sonho", "sufl√™", "sushi", "torta", "trigo", "trufa", "vagem", "vinho", "vodca", "abric√≥", "acelga", "a√ß√∫car", "agri√£o", "alface", "ameixa", "azeite", "bacuri", "banana", "batata", "batida", "bombom", "canap√©", "canela", "caruru", "caviar", "cebola", "cereal", "cereja", "chuchu", "cocada", "cuscuz", "empada", "farofa", "feij√£o", "fondue", "frango", "funghi", "garapa", "geleia", "goiaba", "guandu", "h√≥stia", "inhame", "jatob√°", "jujuba", "lichia", "manjar", "maxixe", "mingau", "mousse", "muffin", "murici", "nachos", "nhoque", "pa√ßoca", "pastel", "pepino", "pernil", "picles", "picol√©", "pinh√£o", "pipoca", "pitaya", "queijo", "quiabo", "rabada", "ricota", "r√∫cula", "salada", "salame", "sals√£o", "sapoti", "sundae", "t√¢mara", "temaki", "tomate", "u√≠sque", "urucum", "vatap√°", "abacate", "abacaxi", "ab√≥bora", "acaraj√©", "acerola", "alecrim", "alfajor", "am√™ndoa", "aspargo", "atem√≥ia", "a√ßafr√£o", "baguete", "beirute", "bisteca", "bolacha", "brioche", "cambuc√°", "canjica", "cenoura", "cerveza", "churros", "coentro", "colorau", "cookies", "costela", "coxinha", "cupcake", "damasco", "empad√£o", "end√≠via", "ervilha", "esfirra", "granola", "granada", "guaran√°", "hortel√£", "iogurte", "ketchup", "laranja", "lasanha", "mangaba", "marisco", "mirtilo", "moranga", "morango", "m√∫sculo", "nuggets", "omelete", "or√©gano", "palmito", "pamonha", "p√£o de l√≥", "picanha", "pimenta", "polenta", "quindim", "ravioli", "repolho", "risoles", "sashimi", "suspiro", "tapioca", "tequila", "torrada", "torrone", "vinagre", "waffles", "ado√ßante", "amendoim", "azeitona", "biscoito", "br√≥colis", "croquete", "feijoada", "gelatina", "gengibre", "goiabada", "limonada", "macarr√£o", "maionese", "mandioca", "maracuj√°", "melancia", "merengue", "mostarda", "panetone", "panqueca", "parmes√£o", "pirulito", "pistache", "presunto", "r√°dio", "raspberry", "salpic√£o", "sequilho", "talharim", "torresmo", "tortilla", "uva passa", "vitamina", "yakisoba", "brigadeiro", "caipirinha", "cheesecake", "dobradinha", "energ√©tico", "gorgonzola", "hamb√∫rguer", "jabuticaba", "manjeric√£o", "mousse de maracuj√°", "p√£o de queijo", "petit g√¢teau", "suco de ma√ß√£", "vinho branco", "abacaxi", "doce de leite", "feij√£o preto", "leite de coco", "marshmallow", "panqueca", "torta de lim√£o",
  ];
  window.respostasAcerto_verbos = [
    "correr", "pular", "andar", "dormir", "comer", "beber", "rir", "chorar", "gritar", "sentar", "levantar", "voar", "nadar", "escrever", "ler", "cozinhar", "dirigir", "estudar", "trabalhar", "brincar", "dan√ßar", "cantar", "pensar", "olhar", "escutar", "comprar", "vender", "abrir", "fechar", "limpar", "lavar", "cortar", "desenhar", "pintar", "telefonar", "enviar", "receber", "aprender", "ensinar", "viajar", "nadar", "mergulhar", "abra√ßar", "beijar", "chutar", "atacar", "defender", "ganhar", "perder", "apagar", "acender", "consertar", "quebrar", "dobrar", "empurrar", "puxar", "subir", "descer", "esperar", "achar", "procurar", "encontrar", "falar", "sussurrar", "telefonar", "caminhar", "pescar", "plantar", "regar", "correr", "saltar", "arremessar", "pegar", "soltar", "vestir", "tirar", "ganhar", "perder", "brigar", "lutar", "treinar", "apertar", "abrir", "fechar", "ligar", "desligar", "gritar", "sorrir", "chorar", "acenar", "aplaudir", "co√ßar", "rasgar", "costurar", "acordar", "dormir", "respirar", "beber", "comer", "provar", "encher", "esvaziar", "pintar", "desenhar", "fotografar", "filmar", "correr", "cantar", "dan√ßar", "saltar", "atirar", "capturar", "explodir", "salvar", "esconder", "ca√ßar", "jogar", "assistir", "ouvir", "cozinhar", "preparar", "arrumar", "bagun√ßar", "ganhar", "perder"
  ];
  window.respostasAcerto_animais = [
    "cachorro", "gato", "le√£o", "tigre", "elefante", "girafa", "macaco", "coelho", "cavalo", "vaca", "porco", "ovelha", "galinha", "pato", "ganso", "cabra", "lobo", "raposa", "urso", "pantera", "on√ßa", "jacar√©", "crocodilo", "tartaruga", "jabuti", "cobra", "cobra-cega", "camale√£o", "iguana", "lagarto", "sapo", "r√£", "peixe", "tubar√£o", "golfinho", "baleia", "polvo", "lula", "caranguejo", "lagosta", "avestruz", "pav√£o", "pardal", "coruja", "√°guia", "falc√£o", "papagaio", "periquito", "tucano", "pinguim", "urso-pardo", "canguru", "koala", "ornitorrinco", "tamandu√°", "pregui√ßa", "hiena", "crocodilo-do-nilo", "cavalo-marinho", "estrelado-do-mar", "abelha", "formiga", "aranha", "borboleta", "vaca-leiteira", "bode", "porquinho-da-√≠ndia", "hamster", "chinchila", "raposa-do-√°rtico", "l√™mure", "orangotango", "gorila", "chimpanz√©", "baleia-azul", "baleia-jubarte", "golfinho-rosa", "tubar√£o-branco", "tubar√£o-martelo", "jacar√©-a√ßu", "elefante-africano", "elefante-asi√°tico", "cobra-real", "cobra-cega", "c√°gado", "jabuti-tortoise", "galinha-d'angola", "pato-real", "cisne", "ganso-do-canad√°", "tucano-toco", "avestruz-africano", "papagaio-do-congo", "periquito-australiano", "coruja-das-torres", "√°guia-careca", "falc√£o-peregrino", "canguru-vermelho", "koala-australiano", "ornitorrinco-australiano", "tamandu√°-bandeira", "pregui√ßa-de-tr√™s-dedos", "hiena-malhada", "l√™mure-de-cauda-anelada", "raposa-vermelha", "gato-selvagem", "cachorro-do-mato", "cervo", "alce", "bisonte", "urso-pardo-europeu", "urso-negro", "lobo-guar√°", "guepardo", "leopardo", "pantera-negra", "elefante-an√£o", "tigre-de-bengala", "tigre-siberiano", "cavalo-marinho", "carpa", "til√°pia", "piranha", "polvo-gigante", "lula-gigante", "peixe-palha√ßo", "peixe-dourado", "salm√£o", "bacalhau", "camar√£o", "lagosta", "caranguejo-azul", "medusa", "estrelado-do-mar", "bicho-pregui√ßa", "porco-espinho", "ouri√ßo-do-mar", "tatu", "raposa-do-deserto"
  ];

  window.pararTentativaAcerto = false;
  window.desenhoCancelado = false;
  window.acertou = false;
  window.esperandoNovaPartida = false;
  window.tentativasDesenhoAtual = [];
  window.respostasReveladas = [];

  let storedKey = "gartic_chat_log";
  let chatLog = JSON.parse(localStorage.getItem(storedKey)) || [];

  // Carregar Vue e Lucide UMD dinamicamente
  function loadVue(callback) {
    if (window.Vue && window.lucide) {
      callback();
      return;
    }
    // Carregar Vue
    const scriptVue = document.createElement("script");
    scriptVue.src = "https://unpkg.com/vue@3/dist/vue.global.prod.js";
    scriptVue.onload = () => {
      // Carregar Lucide somente ap√≥s Vue
      const scriptLucide = document.createElement("script");
      scriptLucide.src = "https://unpkg.com/lucide@latest";
      scriptLucide.onload = callback;
      document.head.appendChild(scriptLucide);
    };

    document.head.appendChild(scriptVue);
  }

  loadVue(() => {
    const {
      createApp,
      ref,
      onMounted,
      watch,
      computed,
      onUnmounted
    } = Vue;

    const userStartTime = new Date();

    const boxId = "gartic-float-box-vue";
    const isAntiIdle = ref(true);
    const acertou = ref(window.acertou);
    const esperandoNovaPartida = ref(window.esperandoNovaPartida);

    // Cria container
    const container = document.createElement("div");
    container.id = "gartic-float-box-vue";

    if (document.getElementById(boxId)) {
      console.warn("[Gartic Vue] J√° existe uma inst√¢ncia ativa.");
      return;
    }

    Object.defineProperty(window, "acertou", {
      get() {
        return acertou.value;
      },
      set(val) {
        acertou.value = val;
      },
    });
    Object.defineProperty(window, "esperandoNovaPartida", {
      get() {
        return esperandoNovaPartida.value;
      },
      set(val) {
        esperandoNovaPartida.value = val;
      },
    });

    const Button = {
      props: {
        text: { type: String, required: true },
        iconHtml: { type: String, required: false },
        color: { type: String, default: "#4B5563" },
        size: { type: [Number, String], default: 14 },
        show: { type: Boolean, default: true },
        onClick: { type: Function, required: true },
      },
      setup(props) {
        return { props };
      },
      template: `
    <button 
        v-show="props.show" 
        @click="props.onClick" 
        :style="{
          backgroundColor: props.color, 
          height: '30px', 
          minWidth: '120px', 
          border: 'none', 
          borderRadius: '5px', 
          flex: 1, 
          display: 'flex', 
          justifyContent: 'center', 
          alignItems: 'center', 
          gap: '3px'
        }"
        :title="props.text"
      >
        <div v-html="props.iconHtml"></div>
        {{ props.text }}
      </button>
      `,
    };

    // Componente Vue
    const App = {
      components: { Button },
      setup() {
        const messages = ref([]);
        const isDragging = ref(false);
        const pos = ref({ x: 10, y: 10 });
        const size = ref({ w: 300, h: window.innerHeight - 50 });
        const chatLogReactive = ref(chatLog);
        const skipDraw = ref(true);
        const messagesFontSize = ref(10);
        const showMessages = ref(true);
        const showSystemMessages = ref(false);
        const acertosCount = ref(0);
        const partidasCount = ref(1);
        const isAutoRespond = ref(true);
        const search = ref("");
        const suggestions = ref([]);
        const searchSuggestionsInput = ref(null);
        const suggestionIndex = ref(-1);
        const suggestionListRef = ref(null);
        const searchMessage = ref("");
        const showSearchMessage = ref(false);

        const elapsed = ref(0); // em segundos
        let interval = null;
        const authorColors = {};

        // filtra mensagens e adiciona cor aleatoria a cada mensagem
        const filteredMessages = computed(() => {
          return messages.value
            .filter((m) => {
              if (searchMessage.value) {
                return (
                  m.text
                    .toLowerCase()
                    .includes(searchMessage.value.toLowerCase()) ||
                  m.name
                    .toLowerCase()
                    .includes(searchMessage.value.toLocaleLowerCase())
                );
              }
              if (m.isSystem && !showSystemMessages.value) {
                return false;
              }
              return true;
            })
            .map((m) => {
              if (!authorColors[m.name]) {
                authorColors[m.name] = getRandomColor();
              }
              return {
                ...m,
                color: authorColors[m.name], // adiciona cor fixa do autor
              };
            });
        });

        const getRandomColor = () => {
          const letters = "0123456789ABCDEF";
          let color = "#";
          for (let i = 0; i < 6; i++) {
            color += letters[Math.floor(Math.random() * 16)];
          }
          return color;
        };

        // filtra sugestoes baseado no seach
        const filteredSuggestions = computed(() => {
          if (!search.value) return [];
          return suggestions.value.filter((word) =>
            word.toLowerCase().includes(search.value.toLowerCase())
          );
        });

        // formata em hh:mm:ss
        const formattedTime = computed(() => {
          const hours = Math.floor(elapsed.value / 3600);
          const minutes = Math.floor((elapsed.value % 3600) / 60);
          const seconds = elapsed.value % 60;
          return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(
            2,
            "0"
          )}:${String(seconds).padStart(2, "0")}`;
        });

        // observa index alterado com o tab, para scrollar div de sugestoes.
        watch(suggestionIndex, (newValue, oldValue) => {
          if (oldValue % 10 == 0 && oldValue >= 10) {
            // scroll suggestion box.
            const suggestionContainer = document.querySelector(
              "#suggestion-list-area"
            );
            if (suggestionContainer) {
              suggestionContainer.scrollTop = 100;
            }
          }
        });

        let dragAnimationFrame;
        let resizeAnimationFrame;

        const startDrag = (e) => {
          e.preventDefault();
          const startX = e.clientX;
          const startY = e.clientY;
          const offsetX = startX - pos.value.x;
          const offsetY = startY - pos.value.y;

          const onMouseMove = (ev) => {
            if (dragAnimationFrame) cancelAnimationFrame(dragAnimationFrame);
            dragAnimationFrame = requestAnimationFrame(() => {
              pos.value.x = ev.clientX - offsetX;
              pos.value.y = ev.clientY - offsetY;
            });
          };

          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
            isDragging.value = false;
          };

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
          isDragging.value = true;
        };

        const startResize = (e) => {
          e.preventDefault();
          const startX = e.clientX;
          const startY = e.clientY;
          const startW = size.value.w;
          const startH = size.value.h;

          const onMouseMove = (ev) => {
            if (resizeAnimationFrame)
              cancelAnimationFrame(resizeAnimationFrame);
            resizeAnimationFrame = requestAnimationFrame(() => {
              size.value.w = startW + (ev.clientX - startX);
              size.value.h = startH + (ev.clientY - startY);
            });
          };

          const onMouseUp = () => {
            document.removeEventListener("mousemove", onMouseMove);
            document.removeEventListener("mouseup", onMouseUp);
          };

          document.addEventListener("mousemove", onMouseMove);
          document.addEventListener("mouseup", onMouseUp);
        };

        const loadSuggestions = () => {
          const tipo = getTipoSala();
          switch (tipo) {
            case "objetos":
              suggestions.value = window.respostasAcerto_objetos || [];
              break;
            case "alimentos":
              suggestions.value = window.respostasAcerto_alimentos || [];
              break;
            case "verbos":
              suggestions.value = window.respostasAcerto_verbos || [];
              break;
            case "animais":
              suggestions.value = window.respostasAcerto_animais || [];
              break;
            case "geral":
              suggestions.value = [
                ...(window.respostasAcerto_objetos || []),
                ...(window.respostasAcerto_alimentos || []),
                ...(window.respostasAcerto_verbos || []),
                ...(window.respostasAcerto_animais || []),
              ];
              break;
          }
        };

        // Bot√µes -> chamam fun√ß√µes globais
        const ativarAntiIdle = () => {
          // window.ativarAntiIdle();
          isAntiIdle.value = true;
        };
        const desativarAntiIdle = () => {
          // window.desativarAntiIdle();
          isAntiIdle.value = false;
        };
        const tentarAcerto = () => window.tentarAcerto();
        const darResposta = (resposta) => window.darResposta(resposta);
        const pararTentarAcerto = () => {
          window.pararTentarAcerto();
        };
        const getTipoSala = () => window.getTipoSala();
        const getDescSala = () => window.getDescSala();
        const limparChat = () => {
          messages.value = [];
        };
        const excluirChat = () => {
          // messages.value = [];
          // excluir mensagens do storage
          localStorage.removeItem(storedKey);
          console.log("[Gartic Bot] %climpando chat...", "color: gray;");
          setTimeout(() => {
            console.log("[Gartic Bot] %cchat limpo...", "color: green;");
          }, 800)
        };
        const getNickname = () => window.getAtualUsuarioNickname();
        const incrementMessagesFontSize = () => {
          if (messagesFontSize.value < 25) {
            messagesFontSize.value++;
          }
        };
        const decrementMessagesFontSize = () => {
          if (messagesFontSize.value > 5) {
            messagesFontSize.value--;
          }
        };
        const toggleShowMessages = () =>
          (showMessages.value = !showMessages.value);
        const toggleShowSystemMessages = () =>
          (showSystemMessages.value = !showSystemMessages.value);
        const toggleShowSearchMessages = () =>
          (showSearchMessage.value = !showSearchMessage.value);

        const onSearchPressEnter = () => {
          setTimeout(() => {
            searchSuggestionsInput.value?.focus();
          }, 10);
          if (suggestionIndex.value >= 0) {
            // pega resposta indicada pelo index
            search.value = filteredSuggestions.value[suggestionIndex.value];
            if (search.value) {
              sendAwnser(search.value);
              search.value = "";
              suggestionIndex.value = -1;
            }
            return;
          }

          // enviar o que ta no search
          sendAwnser(search.value);
          search.value = "";
          suggestionIndex.value = -1;
        };

        const onSearchPressTab = () => {
          setTimeout(() => {
            searchSuggestionsInput.value?.focus();
          }, 10);
          if (suggestionIndex.value == filteredSuggestions.value.length) {
            suggestionIndex.value = 0;
          } else {
            suggestionIndex.value++;
          }
        };

        const onSearchPressBackspace = () => {
          suggestionIndex.value = -1;
        };

        const sendSuggestion = () => {
          sendAwnser(search.value);
          search.value = "";
        };
        const selectSuggestion = (item) => {
          search.value = item; // preenche o input com a sugest√£o
        };

        const sendAwnser = (awnser) => {
          if (!window.esperandoNovaPartida) {
            if (awnser) darResposta(awnser);
          }
        };

        const suggestionInputPlaceholder = computed(() => {
          return !window.esperandoNovaPartida ? "Buscar sugest√µes..." : "Voc√™ acertou!"
        })

        onMounted(() => {
          // Carrega sugestoes
          loadSuggestions();

          lucide.createIcons();

          interval = setInterval(() => {
            const now = new Date();
            elapsed.value = Math.floor((now - userStartTime) / 1000);
          }, 1000);

          const stored = JSON.parse(
            localStorage.getItem("gartic_chat_log") || "[]"
          );
          messages.value.push(...stored);

          // texto do input de sugestao


          // observa
          const chatTarget = document.querySelector("#chat .historico .lista");
          const respostasTarget = document.querySelector(
            "#respostas .historico .lista"
          );
          const popupContentTarget = document.querySelector("#popup");
          const desenhoTarget = document.querySelector("#desenho #alerta");

          if (chatTarget) {
            if (window._garticChatObserver) {
              window._garticChatObserver.disconnect();
            }
            // cria observer do chat
            window._garticChatObserver = new MutationObserver((muts) => {
              muts.forEach((m) => {
                m.addedNodes.forEach((node) => {
                  if (node.nodeType === 1) {
                    if (
                      node.classList.contains("erro") &&
                      node.textContent.includes("Mensagem ofensiva")
                    ) {
                      console.log("[Gartic Bot] Mensagem ofensiva bloqueada ");
                      return;
                    }

                    const { name, text, timestamp, isSelf, isSystem } =
                      extractMessageData(node);

                    if (name && text) {
                      const data = { name, text, timestamp, isSelf, isSystem };
                      const exists = chatLogReactive.value.some(
                        (e) => e.name === data.name && e.text === data.text
                      );
                      if (!exists) {
                        chatLogReactive.value.push(data);
                        saveChatLog(chatLogReactive.value);
                        messages.value.push(data);
                        const msgContainer = document.querySelector(
                          "#messages-container"
                        );
                        setTimeout(() => {
                          if (msgContainer) {
                            // msgContainer.scrollTop = msgContainer.scrollHeight;
                          }
                        }, 50);
                      }
                    }
                  }
                });
              });
            });
            window._garticChatObserver.observe(chatTarget, { childList: true });
          }

          if (respostasTarget) {
            if (window._garticRespostaObserver) {
              window._garticRespostaObserver.disconnect();
            }
            var ultimaDicaTentativa = null;
            // cria observer das respostas
            window._garticRespostaObserver = new MutationObserver((muts) => {
              muts.forEach((m) => {
                m.addedNodes.forEach((node) => {
                  if (node.nodeType !== 1) return;

                  // fim de jogo
                  if (
                    node.classList.contains("sistema") &&
                    node.textContent.includes("Fim de jogo")
                  ) {
                    const vencedor = node
                      .querySelector("strong")
                      ?.textContent.trim();
                    console.log(
                      "[Gartic Bot] O jogo terminou: vencedor ",
                      vencedor
                    );

                    // if (palavra && !window.respostasReveladas.includes(palavra)) {
                    //   window.respostasReveladas.push(palavra);
                    // }
                  }

                  // termino de jogada
                  if (
                    node.classList.contains("sistema") &&
                    node.textContent.includes("A resposta era")
                  ) {
                    const palavra = node
                      .querySelector("strong")
                      ?.textContent.trim();
                    console.log("[Gartic Bot] A resposta era:", palavra);

                    if (
                      palavra &&
                      !window.respostasReveladas.includes(palavra)
                    ) {
                      window.respostasReveladas.push(palavra);
                    }
                  }

                  // deu dica
                  if (
                    node.classList.contains("sistema") &&
                    node.textContent.includes("Dica")
                  ) {
                    // const palavra = node.querySelector("strong")?.textContent.trim();
                    console.log("[Gartic Bot] Dica dada: ", node.textContent);

                    // tenta acerto ao receber dica, se o auto responder estiver ativado
                    if (isAutoRespond.value == true) {
                      if (ultimaDicaTentativa) {
                        clearTimeout(ultimaDicaTentativa);
                        window.pararTentativaAcerto = true;
                      }
                      ultimaDicaTentativa = setTimeout(() => {
                        window.pararTentativaAcerto = false;
                        window.tentarAcerto();
                      }, 500);
                    }
                  }

                  // termino de jogada - cancelado
                  if (
                    node.classList.contains("sistema") &&
                    node.textContent.includes("Desenho cancelado")
                  ) {
                    console.log("[Gartic Bot] O desenho foi cancelado");
                    window.desenhoCancelado = true;
                    window.esperandoNovaPartida = true;
                  }

                  // termino de jogada - intervalo - sempre?
                  if (
                    node.classList.contains("sistema") &&
                    node.textContent.includes("Intervalo")
                  ) {
                    console.log("[Gartic Bot] Intervalo.. jogada resetada");
                    window.desenhoCancelado = true;
                    window.esperandoNovaPartida = true;
                    window.tentativasDesenhoAtual = [];
                  }

                  // nova jogada - de outro jogador
                  if (
                    node.classList.contains("vez") &&
                    node.textContent.includes("Vez de")
                  ) {
                    console.log(
                      "[Gartic Bot] Nova jogada iniciada",
                      node.textContent
                    );
                    acertou.value = false;
                    window.acertou = false;
                    window.esperandoNovaPartida = false;
                    window.desenhoCancelado = false;
                    window.tentativasDesenhoAtual = [];
                    partidasCount.value++;
                  }

                  // nova jogada - sua
                  if (
                    node.classList.contains("vez") &&
                    node.textContent.includes("Sua vez")
                  ) {
                    console.log("[Gartic Bot] Sua vez de desenhar");
                    acertou.value = false;
                    window.acertou = false;
                    window.esperandoNovaPartida = false;
                    window.desenhoCancelado = false;
                    window.tentativasDesenhoAtual = [];
                    partidasCount.value++;
                  }

                  // ao acertar
                  if (
                    node.classList.contains("acerto") &&
                    node.textContent.includes("Voc√™ acertou")
                  ) {
                    console.log("[Gartic Bot] Voc√™ acertou o desenho");
                    window.acertou = true;
                    window.esperandoNovaPartida = true;
                    acertou.value = true;
                    acertosCount.value = acertosCount.value + 1;
                  }
                });
              });
            });
            window._garticRespostaObserver.observe(respostasTarget, {
              childList: true,
            });
          }

          if (popupContentTarget) {
            if (window._garticPopupObserver) {
              window._garticPopupObserver.disconnect();
            }

            // cria observer das respostas
            window._garticPopupObserver = new MutationObserver((muts) => {
              muts.forEach((m) => {
                m.addedNodes.forEach(({ textContent }) => {
                  let text = textContent.toLowerCase();

                  if (text?.includes("sair")) {
                    console.log("[Gartic Bot] Modal de sair acionado");
                  }
                  if (text === "denunciar") {
                    console.log("[Gartic Bot] Modal de denunciar acionado");
                  }
                  if (text?.includes("inatividade")) {
                    console.log("[Gartic Bot] Modal de inatividade acionado");
                    if (isAntiIdle.value == true) {
                      setTimeout(() => {
                        document
                          .querySelector("#popup .botoes #popupBt1")
                          ?.click();
                      }, 50);
                    }
                  }
                  if (text?.includes("pular")) {
                    console.log("[Gartic Bot] Modal de pular desenho acionado");
                    if (skipDraw.value == true) {
                      document
                        .querySelector("#popup .botoes #popupBt1")
                        ?.click();
                    }
                  }
                });
              });
            });
            window._garticPopupObserver.observe(popupContentTarget, {
              childList: true,
              subtree: true,
            });
          }

          const texto1 = document.querySelector("#alerta .texto1");
          if (texto1) {
            if (window._garticDesenhoObserver) {
              window._garticDesenhoObserver.disconnect();
            }
            // cria observer do desenho
            window._garticDesenhoObserver = new MutationObserver((muts) => {
              muts.forEach((m) => {
                if (m.type === "characterData" || m.type === "childList") {
                  if (texto1.textContent.trim().includes("Sua vez")) {
                    console.log("[Gartic Bpt] üé® √â sua vez de desenhar!");
                    // exemplo: clicar automaticamente no bot√£o desenhar
                    if (skipDraw.value == true) {
                      setTimeout(() => {
                        document.querySelector("#dica .btPular")?.click();
                        setTimeout(() => {
                          document
                            .querySelector("#popup .botoes #popupBt1")
                            ?.click();
                        }, 50);
                      }, 50);
                    }
                  }
                }
              });
            });
            window._garticDesenhoObserver.observe(texto1, {
              childList: true,
              subtree: true,
              characterData: true,
            });
          }
        });

        onUnmounted(() => {
          clearInterval(interval);
        });

        return {
          filteredMessages,
          pos,
          size,
          isAntiIdle,
          skipDraw,
          messagesFontSize,
          showMessages,
          esperandoNovaPartida,
          showSystemMessages,
          formattedTime,
          acertosCount,
          partidasCount,
          isAutoRespond,
          searchSuggestionsInput,
          suggestionIndex,
          suggestionListRef,
          search,
          searchMessage,
          showSearchMessage,
          suggestions,
          filteredSuggestions,
          suggestionInputPlaceholder,
          selectSuggestion,
          sendSuggestion,
          onSearchPressTab,
          onSearchPressEnter,
          onSearchPressBackspace,
          toggleShowSearchMessages,
          toggleShowSystemMessages,
          toggleShowMessages,
          decrementMessagesFontSize,
          incrementMessagesFontSize,
          getNickname,
          limparChat,
          excluirChat,
          getDescSala,
          startDrag,
          startResize,
          ativarAntiIdle,
          desativarAntiIdle,
          tentarAcerto,
          pararTentarAcerto,
        };
      },
      template: `
        <div :id="boxId"
             :style="{
               position: 'fixed',
               top: pos.y + 'px',
               left: pos.x + 'px',
               width: size.w + 'px',
               height: size.h + 'px',
               backgroundColor: '#1E293B',
               color: '#fff',
               fontFamily: 'monospace',
               fontSize: '14px',
               border: '1px solid #ccc',
               borderRadius: '5px',
               display: 'flex',
               flexDirection: 'column',
               zIndex: 9999,
               padding: '10px',
               overflowY: 'auto',
             }
        ">
          <div style="font-weight: bold; text-align:center; cursor:move; user-select:none; margin-bottom:5px;"
               @mousedown="startDrag">
               <span> - ({{getNickname()}} - {{getDescSala()}}) - </span>
               <hr/>
          </div>

          <div style="padding: 4px; background-color: #293548; border-radius: 5px;">
            <table style="font-size: 11px; color: #9AA1AD;">
              <tbody>
                  <tr>
                      <td>
                        <span>Status: <span style="color: black; background-color: #49DC7F; padding: 2px; border-radius: 10px;">Online</span> </span>
                      </td>
                      <td>
                        ({{formattedTime}})
                      </td>
                  </tr>
                  <tr>
                      <td>
                        <span>Partidas: <span>{{partidasCount}}</span></span>
                      </td>
                      <td>
                        <span>Acertos: <span>{{acertosCount}}</span></span>
                      </td>
                  </tr>
                  
                </tbody>
            </table>

            <table style="font-size: 11px; color: #9AA1AD">
              <tbody>
                <tr>
                    <td>
                      <span v-show="isAntiIdle">AntiIdle: <span style="color: #4ADF80;">Ativado</span></span>
                      <span  v-show="!isAntiIdle">AntiIdle: <span style="color: gray;">Desativado</span></span>
                    </td>
                </tr>
                <tr>
                    <td>
                      <div>
                        <span>Pular vez:</span>
                        <label style="color: white; margin-left: 8px;">
                          <input type="radio" :value="true" v-model="skipDraw" />
                          Sim
                        </label>
                        <label style="color: white; margin-left: 8px;">
                          <input type="radio" :value="false" v-model="skipDraw" />
                          N√£o
                        </label>
                      </div>
                    </td>
                </tr>

                <tr>
                  <div>
                    <span>Auto Responder:</span>
                    <label style="color: white; margin-left: 8px;">
                      <input type="radio" :value="true" v-model="isAutoRespond" />
                      Sim
                    </label>
                    <label style="color: white; margin-left: 8px;">
                      <input type="radio" :value="false" v-model="isAutoRespond" />
                      N√£o
                    </label>
                  </div>
                </tr>
                <tr>
                  <span>Esperando Partida: 
                    <span v-if="esperandoNovaPartida" style="color: #EAC117;">Sim</span>
                    <span v-else style="color: #4BE081;">Nao</span>
                  </span>
                </tr
              </tbody>
            </table>
          </div>

          <div style="display:flex; flex-direction:column; margin: 5px 0px">
            
          </div>
          
          <div style="display:flex; gap:5px; flex-wrap: wrap; margin-bottom:5px;">
            <button title="Ativar AntiIdle" v-show="!isAntiIdle" @click="ativarAntiIdle" style="background-color: #16A34A; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;">
              <i width="16" :data-lucide="toggleLeftIcon"></i> Ativar AntiIdle
            </button>

            <button title="Desativar AntiIdle" v-show="isAntiIdle" @click="desativarAntiIdle" style="background-color: #DC2626; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;">
              <i width="16" :data-lucide="toggleRightIcon"></i> Desativar AntiIdle
            </button>
          </div>
          <div style="display:flex; gap:5px; flex-wrap: wrap; margin-bottom:5px;">
            <button :disabled="esperandoNovaPartida" @click="tentarAcerto" style="background-color: #2563EB; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;"> <i width="16" :data-lucide="goalIcon"></i> Tentar Acerto</button>
            <button @click="pararTentarAcerto" style="background-color: #4B5563; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;"> <i width="16" :data-lucide="circleOffIcon"></i> Parar Acerto</button>
          </div>
          <div style="display:flex; gap:5px; flex-wrap: wrap; margin-bottom:5px;">
            <button v-show="showMessages" @click="toggleShowMessages" style="background-color: #4B5563; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1;  display: flex; justify-content: center; align-items: center; gap: 3px;"> <i width="16" :data-lucide="eyeOffIcon"></i> Ocultar Chat</button>
            
            <button v-show="!showMessages" @click="toggleShowMessages" style="background-color: #4B5563; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;"> <i width="16" :data-lucide="eyeIcon"></i> Mostrar Chat</button>
            
            <button @click="limparChat" @dblclick="excluirChat" style="background-color: #4B5563; color: white; height: 30px; min-width: 120px; border: none; border-radius: 5px; flex: 1; display: flex; justify-content: center; align-items: center; gap: 3px;" title="Ao clicar duas vezes, apaga as mensagens para sempre"> <i width="16" :data-lucide="brushCleaningIcon"></i> Limpar Chat</button>
          </div>
          <hr>
          <div>
            <div style="display: flex; align-items: center; justify-content: center; gap: 3px;">
              <input 
                :disabled="esperandoNovaPartida"
                ref="searchSuggestionsInput"
                style="flex: 1; height: 30px; border-radius: 7px;"
                @keydown.tab="onSearchPressTab"
                @keydown.enter="onSearchPressEnter"
                @keydown.backspace="onSearchPressBackspace"
                type="text" 
                v-model="search" 
                :placeholder="suggestionInputPlaceholder"
              />
              <button @click="sendSuggestion" :disabled="!search" title="enviar sugestao" style="padding: 2px 10px; border-radius: 7px;">
                <i width="16" :data-lucide="sendIcon"></i>
              </button>
            </div>

            <ul id="suggestion-list-area" style="font-size: 11px; max-height: 100px; overflow-y: auto; display: flex; flex-wrap: wrap; gap: 15px;" v-show="filteredSuggestions.length">
              <li 
                v-for="(item, index) in filteredSuggestions" 
                :key="index"
                @click="selectSuggestion(item)"
                :style="{
                  cursor: 'pointer',
                  listStyleType: index === suggestionIndex ? 'disc' : 'none',
                  marginLeft: index === suggestionIndex ? '20px' : '0',
                  backgroundColor: index === suggestionIndex ? 'red' : ''
                }"
              >
                {{ item }}
              </li>
            </ul>
          </div>
          <hr>
          <div v-show="showMessages" style="display:flex; justify-content: space-between; align-items: center;">
            <div style="display:flex; justify-content: center; align-items: center; gap: 5px; font-weight:bold; text-align:center; margin-bottom:5px;">
             <i width="16" :data-lucide="messageSquareTextIcon"></i> Hist√≥rico do Chat
            </div>
            
            <div style="display:flex; align-items: center;">
              <button @click="toggleShowSearchMessages" style="background:transparent; color: white; margin-right: 10px; border: none;" :title="showSystemMessages ? 'Ocultar buscador de mensagens' : 'Mostrar buscador mensagens'">
                <i width="16" :data-lucide="searchIcon"></i>
              </button>
              <button @click="toggleShowSystemMessages" style="background:transparent; color: white; margin-right: 10px; border: none;" :title="showSearchMessage ? 'Ocultar mensagens do sistema' : 'Mostrar mensagens do sistema'">%</button>

              <button @click="incrementMessagesFontSize" style="background:transparent; color: white; border: none;" title="Aumentar o tamanho da fonte"> <i width="16" :data-lucide="zoomInIcon"></i> </button>

              {{messagesFontSize}}
              
              <button @click="decrementMessagesFontSize" style="flex: 1;background:transparent; color: white; border: none;" title="Diminuir o tamanho da fonte"><i width="16" :data-lucide="zoomOutIcon"></i></button>
            </div>
          </div>
          <div v-show="showSearchMessage && showMessages">
            <input v-model="searchMessage" placeholder="Procurar no chat..." />
          </div>
          <div 
            v-show="showMessages"
            id="messages-container"
            :style="{
              flex: 1,
              overflowY: 'auto',
              fontSize: messagesFontSize + 'px',
              padding: '2px'
          }">
            <div style="margin: 5px 0px" v-for="(m,i) in filteredMessages" :key="i">

              <span :style="{ backgroundColor: m.isSelf ? '#0055ff' : m.isSystem ? '#ff0022' : '' }">
                {{ m.name }}: <span :style="{ color: m.color}">{{ m.text }}</span>
              </span>
              <br>
              <small style="color: rgb(154, 161, 173)">{{new Date(m.timestamp).toTimeString().split(' ')[0]}}</small>
            </div>
          </div>

          <div v-show="showMessages && false" style="display: flex;">
            <input 
                style="flex: 1; height: 15px;"
                type="text" 
                placeholder="Chat..."
              />
          </div>

          <div style="text-align: center">
            <small> Por: <a target="_blank" href="github.com/jrafael29"> <i>Jos√© Rafael</i> </a> </small>
          </div>

          <div style="position:absolute; right:0; bottom:0; width:10px; height:10px; cursor:nwse-resize;"
               @mousedown="startResize"></div>
          
        </div>
      `,
      data() {
        return {
          iconName: "camera",
          sendIcon: "send-horizontal",
          toggleLeftIcon: "toggle-left",
          toggleRightIcon: "toggle-right",
          circleOffIcon: "circle-off",
          eyeOffIcon: "eye-off",
          eyeIcon: "eye",
          goalIcon: "goal",
          brushCleaningIcon: "brush-cleaning",
          messageSquareTextIcon: "message-square-text",
          zoomInIcon: "zoom-in",
          zoomOutIcon: "zoom-out",
          searchIcon: "search",
          boxId,
        };
      },
    };

    // append no container
    document.body.appendChild(container);

    createApp(App).mount(container);
    console.log("%c[Gartic Bot] Janela flutuante Criada!", "color:green");
  });

  const saveChatLog = (log) =>
    localStorage.setItem(storedKey, JSON.stringify(log));

  function sleep(ms) {
    return new Promise((resolve) => {
      setTimeout(resolve, ms);
    });
  }

  function dicaParaRegex(dica) {
    // Divide por espa√ßos para suportar frases com m√∫ltiplas palavras
    const palavras = dica.trim().split(" ");
    const regexPalavras = palavras.map((palavra) => {
      // Substitui cada 'x' por '.', mantendo as letras vis√≠veis
      return palavra.replace(/x/g, ".");
    });
    // Junta as partes com espa√ßo e retorna uma regex completa com ^ e $
    return new RegExp("^" + regexPalavras.join(" ") + "$", "i");
  }

  function filtrarPorDica(dica, lista) {
    const regex = dicaParaRegex(dica);
    return lista.filter((palavra) => regex.test(palavra));
  }

  // Extrai info da mensagem
  const extractMessageData = (div) => {
    let isSelf = false;
    let isSystem = false;

    if (div.classList.contains("sistema")) {
      // entrou ou saiu da sala
      isSystem = true;
    }

    const strong = div.querySelector("strong");
    if (!strong) return null;

    const nickname = strong.textContent.trim();
    const text = div.textContent.replace(nickname, "").trim();

    if (nickname) {
      // valida se o name da msg √© o name do usuario atual
      isSelf = window.getAtualUsuarioNickname() == nickname;
    }

    return {
      name: nickname,
      text,
      timestamp: new Date().toISOString(),
      isSelf,
      isSystem,
    };
  };

  // Comandos √∫teis no console
  window.verMensagensGartic = () => {
    console.table(chatLog);
    return chatLog;
  };

  window.limparMensagensGartic = () => {
    chatLog = [];
    saveChatLog(chatLog);
    const container = document.getElementById("gartic-float-content");
    if (container) container.innerHTML = "";
    console.log("[Gartic Chat Log] Hist√≥rico limpo.");
  };

  window.removerChat = () => {
    const el = document.getElementById("gartic-float-box");
    if (el) el.remove();
    console.log("chat removido");
  };

  window.criarChat = () => {
    console.log("chat criado");
    createFloatingBox();
  };

  window.obterDica = () => {
    // Seleciona spans de tra√ßos e espa√ßos
    const spans = document.querySelectorAll(
      ".dicaTxt .traco, .dicaTxt .espaco"
    );

    let dica = "";
    spans.forEach((span) => {
      if (span.classList.contains("espaco")) {
        dica += " "; // espa√ßo entre palavras
      } else {
        dica +=
          span.innerHTML === "&nbsp;" || span.textContent.trim() === ""
            ? "_"
            : span.textContent;
      }
    });

    return dica;
  };

  // pega a dica formatada com x no lugar dos espa√ßos em branco
  window.obterDicaFormatada = () => {
    // Seleciona spans ativos + espa√ßos
    const spans = document.querySelectorAll(
      ".dicaAtual .traco.ativo, .dicaAtual .espaco"
    );

    let dicaFormatada = "";
    spans.forEach((span) => {
      if (span.classList.contains("espaco")) {
        dicaFormatada += " "; // mant√©m espa√ßo entre palavras
      } else {
        dicaFormatada +=
          span.innerHTML === "&nbsp;" || span.textContent.trim() === ""
            ? "x"
            : span.textContent;
      }
    });

    return dicaFormatada;
  };

  window.obterRespostaPorDica = (tipo, dica) => {
    if (!tipo && !dica) return false;
    
    let resposta;
    switch (tipo) {
      case "objetos":
        resposta = filtrarPorDica(dica, window.respostasAcerto_objetos);
        break;
      
      case "animais":
        resposta = filtrarPorDica(dica, window.respostasAcerto_animais);
        break;
      
      case "verbos":
        resposta = filtrarPorDica(dica, window.respostasAcerto_verbos);
        break;
      
      case "alimentos":
        resposta = filtrarPorDica(dica, window.respostasAcerto_alimentos);
        break;
      
      case "geral":
        resposta = filtrarPorDica(dica, [
          ...(window.respostasAcerto_objetos || []),
          ...(window.respostasAcerto_alimentos || []),
          ...(window.respostasAcerto_verbos || []),
          ...(window.respostasAcerto_animais || []),
        ])
        break;
    }
    return resposta;
  };

  window.obterRespostaRandomica = (tipo) => {
    if (!tipo) return false;
    let resposta;
    switch (tipo) {
      case "objetos":
        resposta =
          window.respostasAcerto_objetos[
            Math.floor(Math.random() * window.respostasAcerto_objetos.length)
          ];
        break;

      case "animais":
        resposta =
          window.respostasAcerto_animais[
            Math.floor(Math.random() * window.respostasAcerto_animais.length)
          ];
        break;

      case "alimentos":
        resposta =
          window.respostasAcerto_alimentos[
            Math.floor(Math.random() * window.respostasAcerto_alimentos.length)
          ];
        break;
      case "verbos":
        resposta =
          window.respostasAcerto_verbos[
            Math.floor(Math.random() * window.respostasAcerto_verbos.length)
          ];
        break;

      case "geral":
        const todos = [
          ...(window.respostasAcerto_objetos || []),
          ...(window.respostasAcerto_animais || []),
          ...(window.respostasAcerto_alimentos || []),
          ...(window.respostasAcerto_verbos || []),
        ];
        resposta = todos[Math.floor(Math.random() * todos.length)];
        break;
    }
    return resposta;
  };

  window.darResposta = (resposta) => {
    // document.querySelector('#respostas form input').value
    const input = document.querySelector("#respostas form input");
    input.value = resposta;

    if (!tentativasDesenhoAtual.includes(resposta)) {
      tentativasDesenhoAtual.push(resposta);
    }

    const form = document.querySelector("#respostas form");
    form.dispatchEvent(
      new Event("submit", { bubbles: true, cancelable: true })
    );
  };

  window.tentarAcerto = async () => {
    // reseta as flags globais
    // window.desenhoCancelado = false;
    // window.acertou = false;

    if (window.esperandoNovaPartida == true) {
      return;
    }

    const dica = obterDicaFormatada();
    const tipo = getTipoSala();
    console.log("[Gartic Bot] voce esta jogando em: ", { tipo, dica });
    let resposta;
    if (!dica) {
      resposta = obterRespostaRandomica(tipo);
    } else {
      resposta = obterRespostaPorDica(tipo, dica);
    }
    console.log("[Gartic Bot] Resposta", resposta);
    if (resposta && typeof resposta == "string") {
      window.darResposta(resposta);
    } else if (resposta && typeof resposta == "object" && resposta.length) {
      for (const resultado of resposta) {
        if (window.esperandoNovaPartida == true) {
          console.log(
            "[Gartic Bot] Voce ja acertou ou a partida esta em intervalo."
          );
          break;
        }
        if (window.acertou == true) {
          console.log("[Gartic Bot] Voce ja acertou.");
          break;
        }
        if (window.pararTentativaAcerto == true) {
          console.log("[Gartic Bot] Voce ja acertou.");
          break;
        }
        if (resultado) {
          // se ja deu essa resposta no desenho atual, ignora
          if (!tentativasDesenhoAtual.includes(resultado)) {
            window.darResposta(resultado);
            await sleep(1000);
          } else {
            console.log(
              `[Gartic Bot] A resposta: ${resultado}, ja foi dada no desenho atual`
            );
          }
          // darResposta(resultado);
        }
      }
    }
  };

  window.forcarAcerto = async () => {
    window.desenhoCancelado = false;

    const dica = obterDicaFormatada();
    let resultados;

    if (dica) {
      resultados = filtrarPorDica(dica, respostas);
    } else {
      resultados = window.respostasAcerto_objetos;
    }

    for (const resultado of resultados) {
      if (window.esperandoNovaPartida) {
        console.log("[Gartic Bot] Tentativas pausadas: desenho terminou.");
        break;
      }
      darResposta(resultado);
      await sleep(1000);
    }
  };

  window.pararTentarAcerto = () => {
    window.pararTentativaAcerto = true;
    setTimeout(() => {
      window.pararTentativaAcerto = false;
    }, 1000);
  };

  window.obterRespostasReveladas = () => {
    // pegar apenas as respostas que nao contenham nos objetos do arquivo
    const tipo = getTipoSala();

    console.log("[Gartic Bot] respostas", window.respostasReveladas);

    // return window.respostasReveladas;

    let resultado;
    switch (tipo) {
      case "objetos":
        resultado = window.respostasReveladas.filter(
          (p) => !window.respostasAcerto_objetos.includes(p)
        );
        break;
      case "animais":
        resultado = window.respostasReveladas.filter(
          (p) => !window.respostasAcerto_animais.includes(p)
        );
        break;
      case "alimentos":
        resultado = window.respostasReveladas.filter(
          (p) => !window.respostasAcerto_alimentos.includes(p)
        );
        break;
      case "geral":
        break;
    }
    if (resultado) {
      return resultado;
    }
    return [];
  };

  window.todasRespostas = () => {
    return window.respostasAcerto_objetos;
  };

  // objetos | alimentos | geral
  window.getTipoSala = () => {
    return document.title.split(" ")[0].toLocaleLowerCase().trim();
  };
  // objetos 11 | alimentos 9 | geral 18
  window.getDescSala = () => {
    return document.title.split("-")[0].toLocaleLowerCase().trim();
  };

  window.getAtualUsuarioNickname = () => {
    const userNode = document.querySelector(".area .user.proprio");
    if (userNode) {
      const nick = userNode.querySelector(".dados span")?.innerText.trim();
      return nick;
    }
  };

  window.denunciar = () => {
    const denuncEl = document.querySelector(".denunciar");
    if (denuncEl) {
      denuncEl.click();

      // confirm
      document.querySelector("#popupBt1")?.click();
    }
  };

  window.allahuAkbar = () => {
    // window.isAntiIdle = false;
    window._antiIdleInterval = null;
    const oldContainer = document.getElementById("gartic-float-box-vue");
    if (oldContainer) {
      oldContainer.remove(); // remove a inst√¢ncia antiga
    }
  };
})();
